import * as ts from "typescript";

import restify = require("restify");
import URL = require("url");

var log = require('winston');
log.level = 'error';


// Simple service schema declaration.
let serviceSchema = [
    {
        id: "Hello"
    }
];


// ----------------------------------------------------------------------------
// Configuration.
// ----------------------------------------------------------------------------

let sbHost: string = "http://127.0.0.1:8000";

let cacheStageHost: string = "127.0.0.1";
let cacheStagePort: string = "8001";
let cacheStageUrl: string = "http://" + cacheStageHost + ":" + cacheStagePort;
let cacheStageId: string = "CacheStage";
let cacheStageResource: string = "/lookup/cache";

let dbStageHost: string = "127.0.0.1";
let dbStagePort: string = "8002";
let dbStageUrl: string = "http://" + dbStageHost + ":" + dbStagePort;
let dbStageId: string = "DbStage";
let dbStageResource: string = "/lookup/database";

let processingStageHost: string = "127.0.0.1";
let processingStagePort: string = "8003";
let processingStageUrl: string = "http://" + processingStageHost + ":" + processingStagePort;
let processingStageId: string = "ProcessingStage";
let processingStageResource: string = "/lookup/processing";


// ----------------------------------------------------------------------------
// Simple service broker client.
//
// Probably generated by an EntityFramework-like API, similar to that of F#.
// ----------------------------------------------------------------------------

type K<T> = (stage: T, params: any) => void;
type Selector = (ips: string[]) => string;

class ServiceBrokerClient {
    constructor() {
        // TODO: Figure out how stage instantiation works. This is the client,
        // so the references below to `cacheStage` and so on can't be
        // references to running stages, like they are here. For now this is
        // fine, but this will have to change.
        this.stages[cacheStageId] = [
            [cacheStageUrl],
            cacheStageResource,
            this.cacheStage,
            restify.createJsonClient({url: cacheStageUrl})];
        this.stages[dbStageId] = [
            [dbStageUrl],
            dbStageResource,
            this.dbStage,
            restify.createJsonClient({url: dbStageUrl})];
        this.stages[processingStageId] = [
            [processingStageUrl],
            processingStageResource,
            this.processingStage,
            restify.createJsonClient({url: processingStageUrl})];

        this.cacheStage.listen(cacheStagePort);
        this.dbStage.listen(dbStagePort);
        this.processingStage.listen(processingStagePort);
    }

    public resolve(id: string): [string[], string, Stage, restify.Client] {
        return this.stages[id];
    }

    private stages: { [id: string]: [string[], string, Stage, restify.Client] } = { };

    public cacheStage = new CacheStage(cacheStageResource, this);
    public dbStage = new DbStage(dbStageResource, this);
    public processingStage = new ProcessingStage(processingStageResource, this);
}


// ----------------------------------------------------------------------------
// Helper functions.
// ----------------------------------------------------------------------------

function objectAssign(output: Object, ...args: Object[]): Object {  // Provides ES6 object.assign functionality
    for (let index = 0; index < args.length; index++) {
        var source = args[index];
        if (source !== undefined && source !== null) {
            Object.keys(source).forEach((key) => {
                output[key] = source[key];
            });
        }
    }
    return output;
}

// ----------------------------------------------------------------------------
// Stage boilerplate.
//
// Abstract base class all stages inherit from. Contains helpful methods like
// `callcc` that make it easy to call the next stage.
//
// Exists on `ServiceBroker`, but typings are downloaded to client for static
// analysis tooling like dot completion.
// ----------------------------------------------------------------------------

abstract class Stage {
    constructor(private route: string, sbc: ServiceBrokerClient) {
        this.server = restify.createServer({});
        this.server.use(restify.bodyParser({ mapParams: true }));

        this.server.post(
            route,
            (req, res, next) => {
                log.info("stage post listener");
                res.send(201);

                let code = req.params.code;
                let params = req.params;

                delete params.code;

                if (code) {
                    this.handleCode(code, params, sbc);
                }

                return next();
            });
    }

    public listen(...args: any[]) {
        this.port = args[0];
        this.server.listen.apply(this.server, args);

        log.info("Stage listening on port " + this.port + " for resource " +
                 this.route);

        // TODO: Add John's hack for getting the current IP here.
    }

    public forward<T extends Stage>(k: K<T>, params: any, id: string) {
        return this.forwardWithSelector<T>(k, ss => ss[0], params, id);
    }

    public forwardWithSelector<T extends Stage>(k: K<T>, s: Selector,
                                                parameters: any, id: string) {
        let [hosts, resource, stage, client] = sbc.resolve(id);

        let params = this.merge(
            parameters,
            !k
                ? {}
                : { code: k.toString() });

        // POST response.
        client.post(
            resource,
            params,
            (err, req, res, obj) => {
                if (err) {
                    log.error('Error sending to ', hosts, resource, ':\n', err);
                    throw 'Send error';
                }
                if (res.statusCode == 201) {
                    log.info('Request complete for', sbHost, resource);
                    // very important - do nothing... the response will be sent
                    // back via the pipeline. This is just acknowlegement that
                    // the next stage got the request.  
                } else {
                    log.info('not sure why we are here in send');
                }
            });
    }

    private handleCode(code: string, params: Object, sbc: ServiceBrokerClient) {
        if (!code) return;

        try {
            // Wrap function in something with parameters that have known names,
            // so that we can call it easily.
            let toEval = "(function (stage: Stage, params) { var f = " +
                code.replace(/^ *"use strict";/,"") + "; f(stage, params); })";

            toEval = ts.transpile(
                toEval.toString(), { module: ts.ModuleKind.CommonJS });

            var f = eval(toEval);

            f(this, params);
        } catch (err) {
            log.error("Could not eval '", code, "': ", err);
            throw 'Code evaluation error';
        }
    }

    private merge(... args : Object[]) : Object {
        args.unshift({});
        return objectAssign.apply(null, args);
    }

    private port: string
    private server: restify.Server;
    private sbc: ServiceBrokerClient;
}


// ----------------------------------------------------------------------------
// Stages.
//
// Each stage is a service running on a machine. For example, the `CacheStage`
// might just be a TypeScript interface wrapping Redis.
//
// Exists on `ServiceBroker`, but typings are downloaded to client for static
// analysis tooling like dot completion.
// ----------------------------------------------------------------------------

class CacheStage extends Stage {
    public has(k: string): boolean {
        log.info("CacheStage.has(" + k + ")");
        return !(typeof this.store[k] === "undefined");
    }

    public get(k: string): string { return this.store[k]; }

    public set(k: string, v: string): boolean {
        this.store[k] = v;
        return true;
    }

    private store: { [k: string]: string; } = { };
}

class DbStage extends Stage {
    public getThing(k: string): string {
        return "cow";
    }
}

class ProcessingStage extends Stage {
    public doThing(v: string) {
        log.info("ProcessingStage: processing data '" + v + "'");
    }
}


// ----------------------------------------------------------------------------
// Application logic, continuation-passing style!
//
// This exists on the client, and is transmitted to the provisioner, so that it
// can be run on boxes in the cluster.
// ----------------------------------------------------------------------------

// Runs on `CacheStage`. Checks cache for a key; if present, forwards the value
// on to `ProcessingStage`. If it is not, we forward a request to the database.
let getDataAndProcess = (cs: CacheStage, params: any) => {
    if (cs.has(params.key)) {
        let dataToProcess = { value: cs.get(params.key) };

        log.info("CacheStage: Key '" + params.key +
                  "' found; forwarding value '" + dataToProcess.value +
                  "' to processing node");

        cs.forward<ProcessingStage>(processData, dataToProcess,
                                    "ProcessingStage");
    } else {
        log.info("CacheStage: Did not find key '" + params.key +
                  "' in cache; forwarding request to database node");

        cs.forward<DbStage>(cacheAndProcessData, params, "DbStage");
    }
};

// Runs on `DbStage`. Gets value from database, caches it, and forwards that
// data on to `ProcessingStage`.
let cacheAndProcessData = (dbs: DbStage, params: any) => {
    let dataToProcess = { value: dbs.getThing(params.key) };

    log.info("DbStage: Retrieved value '" + dataToProcess.value +
              "' for key '" + params.key +
              "'; forwarding to both `CacheStage` and `ProcessingStage`");

    // Send data back to both the caching stage and the processing stage.
    //
    // NOTE: We'll want to replace the "bogus_value_for_now" below with v when
    // we get Babel integration and can finally lift the environment out and
    // serialize that too.
    dbs.forward<CacheStage>(
        (cs, p) => { cs.set(params, "bogus_value_for_now"); },
        dataToProcess,
        "CacheStage");

    dbs.forward<ProcessingStage>(processData, dataToProcess, "ProcessingStage");
};

// Runs on `ProcessingStage`. Processes a piece of data it recieves.
let processData = (pss: ProcessingStage, params: any) => {
    log.info("ProcessingStage: processing data '" + params.value + "'");

    pss.doThing(params.value);
};


// ----------------------------------------------------------------------------
// Run the example.
// ----------------------------------------------------------------------------
let sbc = new ServiceBrokerClient();

// This request will look up the value for `key` below, process it, and cache
// it if necessary.
let keyToLookup = { key: "your_favorite_key" }
sbc.cacheStage.forward(getDataAndProcess, keyToLookup, "CacheStage");
