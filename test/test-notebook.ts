import restify = require("restify");
import URL = require("url");

import sb = require("../src/core/ServiceBroker");
import stage = require("../src/core/Stage");
import cntm = require("../src/core/Continuum");

var log = require('winston');
log.level = 'error';


// ----------------------------------------------------------------------------
// Configuration.
// ----------------------------------------------------------------------------
const ServiceBrokerPort: string = "9000";
const ServiceBrokerUrl: string = "http://127.0.0.1" + ":" + ServiceBrokerPort;

let cacheStageHost: string = "127.0.0.1";
let cacheStagePort: string = "9001";
let cacheStageUrl: string = "http://" + cacheStageHost + ":" + cacheStagePort;
let cacheStageId: string = "CacheStage";
let cacheStageResource: string = "/lookup/cache";

let dbStageHost: string = "127.0.0.1";
let dbStagePort: string = "9002";
let dbStageUrl: string = "http://" + dbStageHost + ":" + dbStagePort;
let dbStageId: string = "DbStage";
let dbStageResource: string = "/lookup/database";

let processingStageHost: string = "127.0.0.1";
let processingStagePort: string = "9003";
let processingStageUrl: string = "http://" + processingStageHost + ":" + processingStagePort;
let processingStageId: string = "ProcessingStage";
let processingStageResource: string = "/lookup/processing";


// ----------------------------------------------------------------------------
// Continuum implementation.
// ----------------------------------------------------------------------------

type CBContinuation<T> = (continuum: Continuum, stage: T, params: any) => void;

class Continuum extends cntm.ContinuumBase {
    public cacheStage: CacheStageInterface = null;
    public dbStage: DbStageInterface = null;
    public processingStage: ProcessingStageInterface = null;

    public forward<T extends stage.Stage>(toStage: T, params: any,
                                          c: CBContinuation<T>) { 
        return this.forwardWithSelectorImplementation<T, Continuum>(
            toStage,
            params,
            ss => ss[0],
            c);
    }

    public forwardWithSelector<T extends stage.Stage>(toStage: T, params: any,
                                                      s: sb.Selector,
                                                      c: CBContinuation<T>) { 
        return this.forwardWithSelectorImplementation<T, Continuum>(
            toStage,
            params,
            s,
            c);
    }
}


// ----------------------------------------------------------------------------
// Stages Interfaces - all "machine generated" from tool that connects to ServiceBroker
//
// Each stage is a service running on a machine. For example, the `CacheStage`
// might just be a TypeScript class wrapping Redis.
//
// They type of each `Stage` exists on `ServiceBroker`, and can be downloaded
// by the `Continuum` class so that the application developer can take
// advantage of statyc analysis tooling like dot completion.
// ----------------------------------------------------------------------------
interface CacheStageInterface extends stage.Stage { // Auto generated by tool connecting to ServiceBroker
    has: (k: string) => boolean;
    get: (k: string) => string;
    set: (k: string, v: string) => boolean;
    getDataAndProcess: (continuum: cntm.ContinuumBase, cs: CacheStageInterface,
                        params: any) => void // Should be Continuum not ContinuumBase
}

interface DbStageInterface extends stage.Stage { // Auto generated by tool connecting to ServiceBroker
    getThing(k: string): string
    cacheAndProcessData: (continuum: cntm.ContinuumBase, dbs: DbStageInterface,
                          params: any) => void; // Should be Continuum not ContinuumBase 
}

interface ProcessingStageInterface extends stage.Stage {// Auto generated by tool connecting to ServiceBroker
    thingWasProcessed: boolean;
    doThing: (v: string) => void;
    processData: (continuum: cntm.ContinuumBase, pss: ProcessingStageInterface,
                  params: any) => void;// Should be Continuum not ContinuumBase
}


// ----------------------------------------------------------------------------
// Stage implementations - must conform to the interfaces created by the tool
//
// stage developers would write these
// ----------------------------------------------------------------------------

class CacheStage extends stage.Stage implements CacheStageInterface {
    public has(k: string): boolean {
        log.info("CacheStage.has(" + k + ")");
        return !(typeof this.store[k] === "undefined");
    }

    public get(k: string): string { return this.store[k]; }

    public set(k: string, v: string): boolean {
        this.store[k] = v;
        return true;
    }

    public getDataAndProcess = getDataAndProcess; // Pick up global function and hang off interface to stage - could also be defined inline.

    private store: { [k: string]: string; } = {};
}

class DbStage extends stage.Stage implements DbStageInterface {
    public getThing(k: string): string {
        return "cow";
    }
    public cacheAndProcessData = cacheAndProcessData; // Pick up global function and hang off interface to stage
}

class ProcessingStage extends stage.Stage implements ProcessingStageInterface {
    public thingWasProcessed: boolean = false; // Used for tests.

    public doThing(v: string) {
        log.info("ProcessingStage: processing data '" + v + "'");

        // Allow tests to verify function ran.
        this.thingWasProcessed = true;
    }

    public processData(c: Continuum, pss: ProcessingStageInterface, params: any) {  // Demonstrating that implementations can be inline too
        log.info("ProcessingStage: processing data '" + params.value + "'");
        pss.doThing(params.value);
    };
}


// ----------------------------------------------------------------------------
// Application logic, created by stage developer as helper functions
//
// The application developer writes this code, which is transmitted to the
// provisioner, so that it can be run on boxes in the cluster.
//
// NOTICE - these functions NOW only rely on parameters passed in to the continuation.  No globals.
//
// ----------------------------------------------------------------------------

const logCacheHit = (k, v) => `CacheStage: Key '${k}' found; forwarding value '${v}' to processing node`;
const logCacheMiss = (k) => `CacheStage: Did not find key '${k}' in cache; forwarding request to database node`;
const logDbGet = (k, v) => `DbStage: Retrieved value '${v}' for key '${k}'; forwarding to both \`CacheStage\` and \`ProcessingStage\``;

// Runs on `CacheStage`. Checks cache for a key; if present, forwards the value
// on to `ProcessingStage`. If it is not, we forward a request to the database.
function getDataAndProcess(continuum: Continuum,
                           cs: CacheStageInterface, params: any): void {
    if (cs.has(params.key)) {
        let dataToProcess = { value: cs.get(params.key) };

        log.info(logCacheHit(params.key, dataToProcess.value));
        continuum.forward(continuum.processingStage, dataToProcess,
                          (c, ps, state) => ps.processData(c, ps, state));
    } else {
        log.info(logCacheMiss(params.key));
        continuum.forward(continuum.dbStage, params,
                          (c, dbs, state) => dbs.cacheAndProcessData(c, dbs, state));
    }
};

// Runs on `DbStage`. Gets value from database, caches it, and forwards that
// data on to `ProcessingStage`.
function cacheAndProcessData(continuum: Continuum, dbs: DbStageInterface,
                             params: any): void {
    let dataToProcess = { value: dbs.getThing(params.key) };

    log.info(logDbGet(params.key, dataToProcess.value));

    // Send data back to both the caching stage and the processing stage.
    //
    // NOTE: We'll want to replace the "bogus_value_for_now" below with v when
    // we get Babel integration and can finally lift the environment out and
    // serialize that too.
    continuum.forward(continuum.cacheStage, dataToProcess,
                      (c, cs, p) => { cs.set(params, "bogus_value_for_now"); });
    continuum.forward(continuum.processingStage, dataToProcess,
                      (c, ps, p) => { ps.processData(c, ps, p); });
};


// ----------------------------------------------------------------------------
// Run the example.
// ----------------------------------------------------------------------------

// Set up a little cluster.
let configuration = sb.ServiceConfigutor.fromFile(
    "./test/config/simpleOneboxConfig.json",
    "utf8");
let sbs = new sb.ServiceBrokerServer(configuration);
sbs.listen(ServiceBrokerPort);

var c = new Continuum(ServiceBrokerUrl);

c.cacheStage = new CacheStage(c, cacheStageResource, cacheStageId);
c.cacheStage.listen(cacheStagePort);

c.dbStage = new DbStage(c, dbStageResource, dbStageId);
c.dbStage.listen(dbStagePort);

c.processingStage = new ProcessingStage(c, processingStageResource,
                                        processingStageId);
c.processingStage.listen(processingStagePort);


// ----------------------------------------------------------------------------
// Verify code ran with test suite.
// ----------------------------------------------------------------------------

import chai = require('chai');
var expect = chai.expect;

describe('Test experimental Continuum API', () => {
    describe('Verify `ProcessingStage` processed some data', () => {
        it('`ProcessingStage.thingWasProcessed` should be `true`', (done) => {
            let keyToLookup = { key: "your_favorite_key" }
            c.forward(c.cacheStage, keyToLookup,
                              (continuum, thisStage, state) => thisStage.getDataAndProcess(continuum, thisStage, state));
            // HACK. `setTimeout`, used here to ensure service is invoked
            // before we check if it was successful.
            setTimeout(() => {
                expect(c.processingStage.thingWasProcessed).to.equals(true);
                done();
            }, 250);
        });
    });
});
